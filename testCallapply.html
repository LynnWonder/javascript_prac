<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>testCallapply</title>
</head>
<body>
    <script>
        function Fruit(){
            this.color='red';
            this.name='apple';
        }
        Fruit.prototype.say=function(a,b){
            console.info('my color is '+this.color+'--'+a+'-'+b);
        };
        const banana={
            color:'yellow'
        };
        const grape={
            color:'purple'
        };
        let apple=new Fruit();
        apple.say.call(banana,11,12);// banana应用apple.say方法，或者说apple的this指向的是banana
        apple.say.apply(grape,[11,13]);
        console.info(apple.say.bind(grape));
        apple.say.bind(grape,11)(14);
        // bind 两个特点：返回的是一个绑定函数，同时传进bind的参数会和调用绑定函数传进的参数合并为原函数的参数
        Function.prototype.my_bind=function(){
            const my_this=Array.from(arguments).shift();
            const args_first=Array.prototype.slice.call(arguments,1);
            console.info(my_this,args_first);
            const that=this;
            return function(){
                console.info(Array.from(arguments));
                return that.apply(my_this,args_first.concat(Array.from(arguments)));
            }
        };
        apple.say.my_bind(grape,11)(15);
    </script>
</body>
</html>