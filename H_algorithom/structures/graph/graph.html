<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>图</title>
</head>
<body>
<script>
    /**
     * Vertex类保存顶点和边
     * @param label
     * @constructor
     */
    function Vertex(label){
        this.label=label;
        this.wasVisited=false;
    }
    //表示图的边的方法叫做邻接表数组
    /**
     * 图类
     * @param v
     * @constructor
     */
    function Graph(v) {
        this.vertices = v;
        this.edges = 0;
        // 表示图的边的数组
        this.adj = new Array(v);
        for (var i = 0; i < v; i++) {
            this.adj[i] =[];
            // this.adj[i].push('');
        }
        // 表示该顶点是否被遍历过
        this.marked = [];
        this.edgeTo=[];
        for (var i = 0; i < v; i++ ) {
            this.marked[i] = false;
        }
        this.addEdge = addEdge;
        this.showGraph = showGraph;
        this.dfs=dfs;
        this.bfs=bfs;
        this.pathTo=pathTo;
        this.hasPathTo=hasPathTo;
    }
    function addEdge(v, w) {
        this.adj[v].push(w);
        this.adj[w].push(v);
        this.edges++;
    }
    function showGraph() {
        for (var i = 0; i < this.vertices; ++i) {
            console.info(i + "->");
            for (var j = 0; j < this.vertices; ++j) {
                if (this.adj[i][j] !== undefined){
                    console.info(this.adj[i][j] + ' ');
                }
            }
            console.info();
        }
    }

    /**
     * 图的dfs和bfs
     */
    function dfs(v) {
        this.marked[v] = true;
        console.info("dfs Visited vertex:  " + v);
        this.adj[v].forEach(item=>{
            if (!this.marked[item]) {
                this.dfs(item);
            }
        });
    }
    function bfs(v){
        var queue=[];
        this.marked[v]=true;
        queue.push(v);
        while(queue.length>0) {
            var x = queue.shift();
            console.info("bfs Visited vertex:  " + x);
            this.adj[x].forEach(item => {
                if (!this.marked[item]) {
                    this.edgeTo[item]=x;
                    this.marked[item] = true;
                    queue.push(item);
                }
            });
        }
    }

    /**
     * 查找一个图中，从一个顶点到另一个顶点的最短路径,借助了层次遍历的特点
     */
    function pathTo(v){

        var resource=0;
        if(!this.hasPathTo(v)){
            return null;
        }
        var path=[];
        var i=v;
        while(i!==resource){
            path.unshift(i);
            i=this.edgeTo[i];
        }
        path.unshift(resource);
        console.info(path);
        return path;
    }
    function hasPathTo(v){
        return this.marked[v];
    }

    let g = new Graph(7);
    console.info(g);
    g.addEdge(0,1);
    g.addEdge(0,2);
    g.addEdge(1,3);
    g.addEdge(3,4);
    g.addEdge(2,5);
    g.addEdge(5,6);
    g.addEdge(6,4);
    g.showGraph();
    // g.dfs(0);
    g.bfs(0);
    g.pathTo(4);
    const findMinPath=(graph,start,end)=>{
        // 首先进行层次遍历
        let temp=[],edgeTo=[],marked=[];
        start!==undefined&&temp.push(start);
        while(temp.length>0){
            let tempPoint=temp.shift();
            graph.adj[tempPoint].forEach(item=>{
                // 一定要检查这个点是否遍历过，避免出现死循环
               if(!marked[item]){
                   edgeTo[item]=tempPoint;
                   marked[item]=true;
                   temp.push(item);
               }
            })
        }
        let res=[],i=end;
        if(!marked[end]) return null;
        while(i!==start){
            res.unshift(i);
            i=edgeTo[i];
        }
        res.unshift(start);
        console.info(edgeTo);
        return res;
    };
    console.info(findMinPath(g,0,4));
    // console.info(g.adj);
</script>
</body>
</html>