<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>Examples</title>
<meta name="description" content="">
<meta name="keywords" content="">
<link href="" rel="stylesheet">
</head>
<body>
    <script type="text/javascript">
    	//做递归的时候肯定要获取上一步的结果 这种方式并不对 因为没有每次都使用上一次的结果
    	// 所以这种递归方式不对。
		// const compose = (...args) => {
		// 	return (a)=>{
		// 		let len=args.length;
		// 			while(len>1){
		// 				len--;
		// 				args.pop();
		// 				compose(...args)(a);
		// 			}
		// 			if (len==1) {
		// 				console.log(args[0](a))
		// 				return args[0](a);
		// 			}else{
		// 				return a;
		// 			}
		// 	}
		// }
		// const compose=(...args)=>{
		// 	return (a)=>{
		// 		if (args.length<1) {
		// 			return a;
		// 		}else{
		// 			if (args.length==1) {
		// 				return args[0](a);
		// 			}else{
		// 				let res=args.pop()(a);
		// 				// console.log(res);
		// 				return compose(...args)(res);
		// 			}
		// 		}
		// 	}
		// }
		// const compose=(...args)=>{
		// 	return (a)=>{
		// 		if (args.length<1) {
		// 			return a;
		// 		}else{
		// 			let res=args.pop()(a);
		// 		    return args.length==0?res:compose(...args)(res);
		// 		}
		// 	}
		// }
		const compose=(...args)=>{
			return (a)=>{
			    return	args.reduceRight((res0,item,idx,self)=>{
					return item(res0);
				},a);
			}
		}
	const add1 = (x) => (x + 1)
	const mul3 = (x) => (x * 3)
	const div2 = (x) => (x / 2)
	console.log(compose(div2,add1,add1)(5))//div2, mul3, add1, 
	let arr=[1,2,3];
	console.log(...arr);

    </script>
</body>
</html>