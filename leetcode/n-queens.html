<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>N皇后-leetcode-51</title>
</head>
<body>
<script>
    /**
     * n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。
     * 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。
     * 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。
     * 显然从测试用例上看符合问题的解用向量表示，需要搜索一组解的情况,因此满足用回溯法解题的要求
     * 解空间自然就是子集树
     * 扩展规则是n个皇后可以放在任意位置
     * 约束条件是：该位置无皇后，行方向没有，列方向没有，斜方向也没有皇后
     * @param n
     */
    const solveNQueens =n=>{
        let res=new Array(n),res0=[];
        for(let i=0;i<n;i++){
            res[i]=new Array(n).fill('.');
        }
        const feasible=(res0,i,j)=>{
            // todo 位置不合理
            // todo 已经有皇后了
            if(res0[i][j]==='Q'){
                return false;
            }
            // todo 横向纵向有皇后
            for(let k=0;k<n;k++){
                if(res0[i][k]==='Q'||res0[k][j]==='Q'){
                    return false;
                }
            }
            // todo 斜方向有皇后
            // 左上角
            let s=i,t=j;
            while(s>=0&&t>=0){
                if(res0[s][t]==='Q'){
                    return false;
                }else{
                    s--;
                    t--;
                }
            }
            // 右上角
            // s=i;t=j;
            // while(s<n&&t>=0){
            //     if(res0[s][t]==='Q'){
            //         return false;
            //     }else{
            //         s++;
            //         t--;
            //     }
            // }
            // // 左下角
            // s=i;t=j;
            // while(s>=0&&t<n){
            //     if(res0[s][t]==='Q'){
            //         return false;
            //     }else{
            //         s--;
            //         t++;
            //     }
            // }
            // // 右下角
            // s=i;t=j;
            // while(s<n&&t<n){
            //     if(res0[s][t]==='Q'){
            //         return false;
            //     }else{
            //         s++;
            //         t++;
            //     }
            // }
            return true;
        };

        const dfs=k=>{
            if(k>n){
                res0.push(JSON.stringify(res));
            }else{
                // 怎么去考虑第k个皇后的摆放位置呢，显然需要双层循环
                for(let i=0;i<n;i++){
                    for(let j=0;j<n;j++){
                        if(feasible(res,i,j)){
                            res[i][j]='Q';
                            dfs(k+1);
                            res[i][j]='.';
                        }
                    }
                }
            }
        };
        dfs(1);
        res0=[...new Set(res0)];
        for(let i=0;i<res0.length;i++){
            res0[i]=JSON.parse(res0[i]);
            for(let j=0;j<res0[i].length;j++){
                res0[i][j]=res0[i][j].join('');
            }
        }
        return res0;
    };
    console.info(solveNQueens(8));
</script>
</body>
</html>