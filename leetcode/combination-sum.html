<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>组合总和-leetcode-39</title>
</head>
<body>
<script>
    /**
     * 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
     candidates 中的数字可以无限制重复被选取。
     说明：
     所有数字（包括 target）都是正整数。
     解集不能包含重复的组合。
     输入: candidates = [2,3,5], target = 8,
     所求解集为:
     [
       [2,2,2,2],
       [2,3,3],
       [3,5]
     ]
     */
    /**
     * 看一下测试用例的结果就会了解到解是一个子集树，需要搜索一组解
     * 解空间是子集树 取值范围是在候选数中选择
     * 扩展规则：遍历整个候选数组
     * 限制条件：和小于等于目标值
     *
     * @param candidates
     * @param target
     */
    const combinationSum = (candidates, target)=>{
        let res=[],res0=[];
        const sum=(arr,idx)=>{
            let res=0;
            for(let i=0;i<idx;i++){
                res+=arr[i];
            }
            return res;
        };
        const check=(arr,val,k)=>{
            return sum(arr,k)+val<=target;
        };
        const dfs=k=> {
            // 判断条件是总和为target
            if(sum(res0,k)===target){
                res.push((JSON.stringify(res0.slice(0,k).sort())));
                // console.info();
            }else{
                // res0中的每个值都是candinates中的值
                for(let i=0;i<candidates.length;i++){
                    if(check(res0,candidates[i],k)){
                        res0[k]=candidates[i];
                        dfs(k+1);
                        // res0[k]=0;
                    }
                }
            }
        };
        dfs(0);
        return [...new Set(res)].map(item=>JSON.parse(item));
    };
    console.info(combinationSum([2,3,5],8));
    console.info(combinationSum([2,3,6,7],7));
</script>
</body>
</html>