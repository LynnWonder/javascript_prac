<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>20191011review</title>
</head>
<body>
<script>
    /**
     * 实现对数组的去重
     */
    let arr=[7,4,6,5,1,3,6];
    const unique1=arr=>{
        return [...new Set(arr)];
    };
    const unique2=arr=>{
        let obj={};
        /**
         * maybe i am a idiot
         * don't forget  the params of array
         */
        arr.forEach((item,index)=>{
            if(!obj[item]){
                obj[item]=item;
            }
        });
        return Object.values(obj);
        // console.info(obj);
    };
    const unique21=arr=>{
        let obj={};
        let res=[];
        arr.forEach(item=>{
            if (!obj[item]){
                res.push(item);
                obj[item]=1;
            }
        });
        return res;
    };
    /**
     * 第三类方法，借助sort加forEach方法实现
     */
    const unique3=arr=>{
        let res=[];
        arr.sort((a,b)=>a-b);
        arr.forEach((item,idx)=>{
            if (idx===0){
                res.push(item);
            }else{
                if (res[idx-1]!==item){
                    res.push(item);
                }
            }
        });
        return res;
    };
    /**
     * 第四种方法，单纯借助indexOf来解决
     * 复杂度可以达到n*n
     */
    const unique4=arr=>{
        let res=[];
        arr.forEach(item=>{
            if (res.indexOf(item)===-1){
                res.push(item);
            }
        });
        return res;
    };
    /**
     * 第五种方法，也是一种很暴力的解决方式，类似于方法4
     * @param arr
     */
    const unique41=arr=>{
        return arr.filter((item, idx) => {
            return arr.indexOf(item) === idx;
        });
    };
    /**
     * 最后一种方法，最暴力的，时间复杂度一定是n*n
     */
    const unique5=arr=>{
        for (let i=0;i<arr.length-1;i++){
            for (let j=i+1;j<arr.length;j++){
                if (arr[j]===arr[i]){
                    arr.splice(j,1);
                    j--;
                }
            }
        }
        return arr;
    };
    console.info(unique1(arr));
    console.info(unique2(arr));
    console.info(unique21(arr));
    console.info(unique3(arr));
    console.info(unique4(arr));
    console.info(unique41(arr));
    let arr1=[1,2,5,1,2,6,9,6,7];
    console.info(unique5(arr));
    console.info(unique5(arr1));
    /**
     * 数组扁平化
     */
    let arr2=[1,[2,3,4,[5,6],7],8];
    const flat1=arr=>{
        return arr.flat(Infinity);
    };
    /**
     * 通过递归来实现，递归就是函数自己调用自己
     * 迭代是A不停调用B
     * @param arr
     */
    const flat2=arr=>{
        let res=[];
        arr.forEach(item=>{
            if (Array.isArray(item)){
                res=res.concat(flat2(item));
            }else{
                res.push(item);
            }
        });
        return res;
    };
    console.info(flat1(arr2));
    console.info(flat2(arr2));

    /**
     * 递归的应用之：实现深拷贝
     */
    const deepCopy1=param=>{
        let res=Array.isArray(param)?[]:{};
        for(let idx in param){
            if (typeof(param[idx])==='object'){
                res[idx]=deepCopy1(param[idx]);
            }else{
                res[idx]=param[idx];
            }
        }
        return res;
    };
    /**
     * 利用转换成json字符串后，变成基本数据类型，则会新开辟一块内存保存这个数据（基本数据类型保存在栈区）
     * 引用数据类型的引用即指针保存在栈区，而真正的数据内容保存在堆区
     * @param param
     * @returns {any}
     */
    const deepCopy2=param=>{
        return JSON.parse(JSON.stringify(param));
    };
    let obj0={
        name:'lynn',
        age:20,
        friends:[1,2,3],
    };

    let obj1=deepCopy1(obj0);
    let obj2=deepCopy2(obj0);
    obj1.friends.push(4);
    obj2.friends.push(5);
    console.info(obj0,obj1,obj2);
    /**
     * es5 和 es6 增加属性的不同之处
     */
    let obj3={
        name:'lynn',
        age:20,
        friends:[1,2,3],
    };
    /**
     * 实际上也是一层deep copy
     * @type {{name: string, age: number, friends: number[]} & {color: string}}
     */
    let obj4=Object.assign({},obj3,{color:'red'});
    obj4['test']='test';
    obj4.friends.push(5);
    console.info(obj3,obj4);
    let arr3=[1,2,3,4,5];
    let arr4=Object.assign([],arr3);
    arr4.push(6);
    let arr5=[1,2,3,4,5];
    let arr6=Object.assign(arr5,[1,6]);
    arr6.push(7);
    console.info(arr3,arr4);
    console.info(arr5,arr6);
    /**
     * es6实现替换 合并对象
     */
    let obj5={
        name:'lynn',
        age:20,
        friends:[1,2,3],
    };
    let obj6={
        ...obj5,
        color:'red',
    };
    console.info(obj5,obj6);
    /**
     * 实现大整数相加,主要通过数据类型转换加进位设置实现的
     */
    const bigNum=(str1,str2)=>{
        let arr1=str1.split('').reverse();
        let arr2=str2.split('').reverse();
        let res=[];
        let c=0;
        for (let i=0;i<(arr1.length>arr2.length?arr1.length:arr2.length);i++){
            let sum0=parseInt(arr1[i])+parseInt(arr2[i]?arr2[i]:0)+c;
            // console.info(sum0,arr2[i]);
            res.push(sum0%10);
            c=sum0>=10?1:0;
        }
        return res.reverse().join('');
    };
    console.info(bigNum('12345678888','1'));
    /**
     * 来个简洁版 其实这种总是操作最后一位的代码，可以通过数组的pop方法实现，让代码更简洁，但是其实复杂度是一样的
     * 另外注意进位需要大于等于10，不要只大于10
     */
    const bigNum1=(str1,str2)=>{
        let arr1=str1.split('');
        let arr2=str2.split('');
        let res=[];
        let c=0,temp=0;
        /**
         * 同时通过while循环来检查是否遍历完
         */
        while(arr1.length||arr2.length){
            let sum=parseInt((temp=arr1.pop())?temp:0)+parseInt((temp=arr2.pop())?temp:0)+c;
            res.unshift(sum%10);
            c=sum>=10?1:0;
        }
        return res.join('');
    };
    console.info(bigNum('12345678888','1'));
    console.info(bigNum('45486646468484544661134868968','544545867466464646'));
    console.info(bigNum1('45486646468484544661134868968','544545867466464646'));
</script>
</body>
</html>