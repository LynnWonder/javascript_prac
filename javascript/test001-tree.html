<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>Examples</title>
<meta name="description" content="">
<meta name="keywords" content="">
<link href="" rel="stylesheet">
</head>
<body>
    <script type="text/javascript">
    	//二叉树的存储结构和构建
    	// 节点对象
    	function Node(){
    		this.text='';
    		this.leftChild=null;
    		this.rightChild=null;
    	}

    	// 递归构建二叉树
var charecters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'];
function buildTree(node, i) {
    var leftIndex = 2*i+1,             //左孩子节点的索引
      rightIndex = 2*i+2;             //右孩子节点的索引
    if(leftIndex < charecters.length) {       //判断索引的长度是否超过了charecters数组的大小
      var childNode = new Node();         //创建一个新的节点对象
      childNode.text = charecters[leftIndex];   //给节点赋值
      node.leftChild = childNode;         //给当前节点node加入左孩子节点
      buildTree(childNode, leftIndex);      //递归创建左孩子
    }
    if(rightIndex < charecters.length) {      //下面注释参照上面的构建左孩子的节点
      var childNode = new Node();
      childNode.text = charecters[rightIndex];
      node.rightChild = childNode;
      buildTree(childNode, rightIndex);
    }
}
//下面构造二叉树
var node = new Node();
node.text = charecters[0];
buildTree(node, 0);  //索引i是从0开始构建
console.log(node)


//二叉树的前序遍历
function Stack() {
    var stack = new Array();        //存放栈的数组
    //压栈
    this.push = function(o) {
      stack.push(o);
    };
    //出栈
    this.pop = function() {
      var o = stack[stack.length-1];
      stack.splice(stack.length-1, 1);
      return o;
    };
    //检查栈是否为空
    this.isEmpty = function() {
      if(stack.length <= 0) {
        return true;
      }
      else {
        return false;
      }
    };
}
//使用方式如下
// var stack = new Stack();
// stack.push(1);    //现在栈中有一个元素
// stack.isEmpty();   //false , 栈不为空
// alert(stack.pop()); //出栈, 打印1
// stack.isEmpty();   //true, 此时栈为空，因为在调用了stack.pop()之后元素出栈了，所以为空
// 前序遍历
function preOrder(node){
	console.log(node.text)
	if(node.leftChild){
		preOrder(node.leftChild)
	}
	if (node.rightChild) {
		preOrder(node.rightChild)
	}

}
preOrder(node)
var strText="";
function midOrder(node){
	if (node.leftChild) {
		if (node.leftChild.leftChild) {
			midOrder(node.leftChild)
		}
		else{
			strText+=node.leftChild.text
		}
	}
	strText+=node.text;//根节点
	if (node.rightChild) {
		if (node.rightChild.leftChild) {
			midOrder(node.rightChild)
		}else{
			strText+=node.rightChild.text;
		}
	}
}
midOrder(node);
console.log(strText)

var mypost="";
function postOrder(node){
	if (node.leftChild) {
		if (node.leftChild.leftChild) {
			postOrder(node.leftChild);
		}else{
			mypost+=node.leftChild.text;
		}
	}
	if (node.rightChild) {
		if (node.rightChild.leftChild) {
			postOrder(node.rightChild);
		}else{
			mypost+=node.rightChild.text;
		}
	}
	mypost+=node.text

}
postOrder(node);
console.log(mypost)



    </script>
</body>
</html>